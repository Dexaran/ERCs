---
eip: 7417
title: Token Converter
description: Smart-contract service that converts token of one ERC version to another
author: Dexaran (@Dexaran) <dexaran@ethereumclassic.org>
discussions-to: https://ethereum-magicians.org/t/token-standard-converter/15252
status: Review
type: Standards Track
category: ERC
created: 2023-07-27
requires: 20, 165, 223
---

## Abstract

There are currently multiple token standards on the Ethereum chain. This EIP introduces the concept of cross-standard interoperability by creating a service that allows [ERC-20](./eip-20.md) tokens to be upgraded to [ERC-223](./eip-223.md) tokens anytime. [ERC-223](./eip-223.md) tokens can be converted back to [ERC-20](./eip-20.md) version without any restrictions to avoid any problems with backward compatibility and allow different standards to co-exist and become interoperable and interchangeable.

To perform the conversion, a user must deposit tokens of one standard to the Converter contract, which will automatically send tokens of another standard back.

## Motivation

This proposal introduces a concept of a token standard upgrading procedure driven by a specialized smart contract that can convert tokens of one standard to another at any time.

Currently, some tokens are available on different chains with different standards. For example most exchanges support [ERC-20](./eip-20.md) USDT, TRX USDT, BEP-20 USDT, which are, in fact, the same USDT tokens. This proposal intends to introduce a concept where an [ERC-20](./eip-20.md) USDT and [ERC-223](./eip-223.md) USDT can simultaneously be available on Ethereum mainnet and are freely interchangeable.

The address of the deployed Token Converter must be described here to solve the trust issues for the token developers and help them figure out how to interact appropriately with the Converter.

Ethereum already has an established ecosystem of tokens, and [ERC-20](./eip-20.md) is the most adopted standard. However, the need for defined migration processes can be a bottleneck for newer standards adoption. This proposal addresses the problem of coordinating the upgrading process and the backward compatibility problems for [ERC-20](./eip-20.md) and [ERC-223](./eip-223.md) tokens.

The Token Converter is supposed to allow anyone to create an alternative version of an existing token implemented in a different standard. This proposal focuses on [ERC-20](./eip-20.md) and [ERC-223](./eip-223.md) standards and considers their specifics. It is assumed that the most common case would be creation of [ERC-223](./eip-223.md) version for an existing [ERC-20](./eip-20.md) token.

The implementation of this service is an alternative to convincing each token developer to choose an alternative standard at the moment of the token deployment or during the development stage of their project. With this service, there will be no need to choose one standard and stick with it, as every token can be available concurrently.

The implementation of this Token Converter service is supposed to be a contract deployed on the Ethereum mainnet once and forever. Its address will be provided in the text of this proposal to avoid potential trust issues and assure developers that the service they interact with is precisely the one driving the conversion process of existing tokens.

All the [ERC-223](./eip-223.md) tokens created by the Token Converter will be identical in that they all implement the same functions, which return the same values, and there is no ambiguity. This helps to avoid problems where a token deployed during the early stage of a token standard adoption may be implemented improperly, or there can be an ambiguity in the standard itself that would allow developers to implement tokens of one standard in different ways. 

For example, it was a common case with [ERC-20](./eip-20.md) where developers could implement custom logic of the `transfer` function and mess up the return values. The [ERC-20](./eip-20.md) specification declares that a `transfer` function MUST return a `bool` value; however, in practice, we have three different types of [ERC-20](./eip-20.md) tokens that are not compatible with each other:

1. [ERC-20](./eip-20.md) tokens that return `true` on success and revert on an error.
2. [ERC-20](./eip-20.md) tokens that return `true` on success and `false` on an error without reverting the transaction.
3. [ERC-20](./eip-20.md) tokens that do not have return values and revert on an error.

Technically, the third category of tokens is incompatible with [ERC-20](./eip-20.md) standard. However, the USDT token deployed on Ethereum mainnet at `0xdac17f958d2ee523a2206206994597c13d831ec7` address does not implement return values. It is one of the most used tokens, and it is not an option to deny supporting USDT due to its improper implementation of the standard.

The Token Converter eliminates the issue of different development teams implementing the standard with slight modifications, which would result in other versions of the same standard on the mainnet.

At the same time, the Converter enables concurrent token support in other smart contracts, such as decentralized exchanges. The Converter can guarantee that a pair of two tokens, one of which is a wrapper for another, is, in fact, the same token that can be converted from one standard to another at any time. This enables the creation of liquidity pools where two different tokens are treated as if they were one.

## Specification

The key words "MUST," "MUST NOT," "REQUIRED," "SHALL," "SHALL NOT," "SHOULD," "SHOULD NOT," "RECOMMENDED," "NOT RECOMMENDED," "MAY," and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

The Token Converter system comprises two main components:

- Converter contract.

- Wrapper contracts. Each original token can have exactly one wrapper of each standard.

Converter contract can deploy new [ERC-223](./eip-223.md) wrapper contracts for any [ERC-20](./eip-20.md) token without an [ERC-223](./eip-223.md) wrapper. There MUST be exactly one [ERC-223](./eip-223.md) wrapper for each [ERC-20](./eip-20.md) token.

The Converter contract MUST accept deposits of [ERC-20](./eip-20.md) tokens and send [ERC-223](./eip-223.md) tokens to the depositor at a 1:1 ratio. Upon depositing 1234 units of `ERC20 token_A`, the depositor MUST receive exactly 1234 units of `ERC223 token_A`. This is done by issuing new [ERC-223](./eip-223.md) tokens at the moment of [ERC-20](./eip-20.md) deposit. The original [ERC-20](./eip-20.md) tokens MUST be frozen in the Converter contract and available for claiming back.

The Converter contract MUST accept deposits of [ERC-223](./eip-223.md) tokens and send [ERC-20](./eip-20.md) tokens to the depositor at a 1:1 ratio. This is done by releasing the original [ERC-20](./eip-20.md) tokens during the [ERC-223](./eip-223.md) deposit. The deposited [ERC-223](./eip-223.md) tokens must then be burned.

### Token Converter

#### Converter contract methods

##### `getERC20WrapperFor`

```solidity
function getERC20WrapperFor(address _token) public view returns (address)
```

Returns the address of the [ERC-20](./eip-20.md) wrapper for a given token address. Returns `0x0` if there is no [ERC-20](./eip-20.md) version for the provided token address. There can be exactly one wrapper for any given [ERC-223](./eip-223.md) token address created by the Token Converter contract.

##### `getERC223WrapperFor`

```solidity
function getERC223WrapperFor(address _token) public view returns (address)
```

Returns the address of the [ERC-223](./eip-223.md) wrapper for a given token address. Returns `0x0` if there is no [ERC-223](./eip-223.md) version for the provided token address. There can be exactly one [ERC-223](./eip-223.md) wrapper for any given [ERC-20](./eip-20.md) token address created by the Token Converter contract.

##### `getERC20OriginFor`

```solidity
function getERC20OriginFor(address _erc223Token) public view returns (address)
```

Returns the address of the original [ERC-20](./eip-20.md) token for the provided [ERC-223](./eip-223.md) wrapper. Returns `0x0` if the provided `_erc223Token` is not an address of any [ERC-223](./eip-223.md) wrapper created by the Token Converter contract.

##### `getERC223OriginFor`

```solidity
function getERC223OriginFor(address _erc20Token) public view returns (address)
```

Returns the address of the original [ERC-223](./eip-223.md) token for the provided [ERC-20](./eip-20.md) wrapper. Returns `0x0` if the provided `_erc20Token` is not an address of any wrapper created by the Token Converter contract.

##### `predictWrapperAddress`

```solidity
function predictWrapperAddress(address _token,
                                   bool    _isERC20 // Is the provided _token a ERC-20 or not?
                                                    // If it is set as ERC-20 then we will predict the address of a 
                                                    // ERC-223 wrapper for that token.
                                                    // Otherwise we will predict ERC-20 wrapper address.
                                  ) view external returns (address)
```

Wrapper contracts are deployed via `CREATE2` opcode and it is possible to predict the address of a wrapper that has not yet been deployed. The address of a wrapper contract depends on the bytecode; therefore, it is necessary to specify if the address of wrapper [ERC-20](./eip-20.md) or wrapper [ERC-223](./eip-223.md) must be predicted.

Providing `_token` address and `_isERC20 = false` will result in [ERC-20](./eip-20.md) wrapper address being predicted.

Providing `_token` address and `_isERC20 = true` will result in [ERC-223](./eip-223.md) wrapper address being predicted.

##### `createERC223Wrapper`

```solidity
function createERC223Wrapper(address _erc20Token) public returns (address)
```

Creates a new [ERC-223](./eip-223.md) wrapper for a given `_erc20Token` if it does not exist yet. Reverts the transaction if the wrapper already exist. Returns the address of the new wrapper token contract on success.  Reverts if `_erc223Token` is a wrapper created by the Converter.

The deployed contract will be a standard [ERC-223](./eip-223.md) token with `approve` and `transferFrom` functions implemented for backward compatibility.

All [ERC-223](./eip-223.md) wrappers deployed by the Converter will will implement the `standard() pure returns (bytes32)` function which returns `223`. This serves further token standard introspection, as [ERC-165](./eip-165.md) may not be reliable for identifying the internal logic implemented within `transfer` function of a token.

NOTE: This function does not verify the standard of `_erc20Token` because no reliable method of introspection is available to guarantee that the provided token implements a particular standard. As a result, it is possible to create an [ERC-223](./eip-223.md) wrapper for an original [ERC-223](./eip-223.md) token.

##### `createERC20Wrapper`

```solidity
function createERC20Wrapper(address _erc223Token) public returns (address)
```

Creates a new [ERC-20](./eip-20.md) wrapper for a given `_erc223Token` if it does not exist yet. Reverts the transaction if the wrapper already exist. Returns the address of the new wrapper token contract on success. Reverts if `_erc223Token` is a wrapper created by the Converter.

NOTE: This function does not verify the standard of `_erc223Token` because no reliable method of introspection is available to guarantee that the provided token implements a particular standard. As a result, it is possible to create an [ERC-20](./eip-20.md) wrapper for an original [ERC-20](./eip-20.md) token.

##### `wrapERC20toERC223`

```solidity
function wrapERC20toERC223(address _ERC20token, uint256 _amount) public returns (bool)
```

Withdraws `_amount` of [ERC-20](./eip-20.md) tokens from the transaction sender with the `transferFrom` function. Delivers the `_amount` of [ERC-223](./eip-223.md) wrapper tokens to the sender of the transaction. Stores the original tokens at the balance of the Token Converter contract for future claims. Returns `true` on success. The Token Converter must keep record of the amount of [ERC-20](./eip-20.md) tokens that were deposited with `wrapERC20toERC223` function because it is possible to deposit [ERC-20](./eip-20.md) tokens to any contract by directly sending them with `transfer` function.

If there is no [ERC-223](./eip-223.md) wrapper for the `_ERC20token`, then creates it by calling a `createERC223Wrapper(_erc20toke)` function.

There is no particular function for unwrapping [ERC-223](./eip-223.md) wrappers to [ERC-20](./eip-20.md) origin, as this logic is implemented in the `tokenReceived` function of the Converter.

##### `unwrapERC20toERC223`

```solidity
function unwrapERC20toERC223(address _ERC20token, uint256 _amount) public returns (bool)
```

Withdraws `_amount` of [ERC-20](./eip-20.md) tokens from the transaction sender with the `transferFrom` function. Delivers the `_amount` of [ERC-223](./eip-223.md) wrapper tokens to the sender of the transaction. Stores the original tokens at the balance of the Token Converter contract for future claims. Returns `true` on success. The Token Converter must keep record of the amount of [ERC-20](./eip-20.md) tokens that were deposited with `wrapERC20toERC223` function because it is possible to deposit [ERC-20](./eip-20.md) tokens to any contract by directly sending them with the `transfer` function.

If there is no [ERC-223](./eip-223.md) wrapper for the `_ERC20token`, then creates it by calling a `createERC223Wrapper(_erc20toke)` function.


##### `convertERC20`

```solidity
function convertERC20(address _token, uint256 _amount) public returns (bool)
```

Automatically determines if the provided [ERC-20](./eip-20.md) token is a wrapper or not. If it is a wrapper, then executes `unwrapERC20toERC223` function. If the provided token is an origin then executes `wrapERC20toERC223` function.

This function is implemented to significantly simplify the workflow of services that integrate both versions of one token in the same contract and needs to convert tokens automatically through the Converter.

##### `isWrapper`

```solidity
function isWrapper(address _token) public view returns (bool)
```

Returns `true` if the provided `_token` address is an address of a wrapper created by the Converter.

NOTE: This function does not identify the standard of a `_token`. There can be exactly one origin for any wrapper created by the Converter. However, an original token can have two wrappers, one of each standard.

##### `tokenReceived`

```solidity
function tokenReceived(address _from, uint _value, bytes memory _data) public override returns (bytes4)
```

This is a standard [ERC-223](./eip-223.md) transaction handler function, and it is called by the [ERC-223](./eip-223.md) token contract when `_from` is sending `_value` of [ERC-223](./eip-223.md) tokens to `address(this)` address. In the scope of this function, `msg.sender` is the address of the [ERC-223](./eip-223.md) token contract and `_from` is the sender of the token transfer.

Automatically determines 

If `msg.sender` is an address of [ERC-223](./eip-223.md) wrapper created by the Token Converter, then the `_value` of [ERC-20](./eip-20.md) original token must be sent to the `_from` address.

If `msg.sender` is not an address of any [ERC-223](./eip-223.md) wrapper known to the Token Converter, then it is considered a [ERC-223](./eip-223.md) origin, and `_value` amount of [ERC-20](./eip-20.md) wrapper tokens must be sent to the `_from` address. If the [ERC-20](./eip-20.md) wrapper for the `msg.sender` token does not exist then create it first.

Returns `0x8943ec02`.

##### `extractStuckERC20`

```solidity
function extractStuckERC20(address _token)
```

This function allows to extract the [ERC-20](./eip-20.md) tokens directly deposited into the contract with a `transfer` function to prevent users who may send tokens by mistake from permanently losing their tokens. Since the Token Converter calculates the number of tokens that were deposited legitimately with the `convertERC20toERC223` function, it is always possible to calculate the amount of "accidentally deposited tokens" by subtracting the recorded amount from the returned value of the `balanceOf( address(this) )` function called on the [ERC-20](./eip-20.md) token contract.

### Converting [ERC-20](./eip-20.md) tokens to [ERC-223](./eip-223.md)

To convert [ERC-20](./eip-20.md) tokens to [ERC-223](./eip-223.md) the token holder should:

1. Call the `approve` function of the [ERC-20](./eip-20.md) token and allow Token Converter to withdraw tokens from the token holders address via the `transferFrom` function.
2. Wait for the transaction with `approve` to be submitted to the blockchain.
3. Call the `convertERC20toERC223` function of the Token Converter contract.

### Converting [ERC-223](./eip-223.md) wrapper tokens back to [ERC-20](./eip-20.md)

To convert [ERC-20](./eip-20.md) tokens to [ERC-223](./eip-223.md), the token holder should:

1. Send [ERC-223](./eip-223.md) tokens to the address of the Token Converter contract via the `transfer` function of the [ERC-223](./eip-223.md) token contract.

## Rationale

### `payable` transfer function workflow

[ERC-223](./eip-223.md) `transfer(address, uint, bytes calldata)` function may be declared `payable`, allowing deposits of ether along with tokens sent.

It may be the most comfortable approach to declare `tokenReceived` function `payable` as well and handle the deposits of ether there. In this case a contract developer would be able to implement all the logic related to the deposits of any assets in one place without a need to declare `receive() payable` function and worry about concurrently executed functions and the order of actions.

However, this creates a difficulty related to the overriding of functions in Solidity. For example, if we want to use this approach then we need to declare `tokenReceived` as `payable` in `IERC223Recipient` interface contract. Otherwise the compiler would throw a "sending ether to nonpayable function" error in case of this code:
```solidity
if (msg.value > 0) {
    // Possible solution
    IERC223Recipient(_to).tokenReceived{value: msg.value}(msg.sender, _value, _data);
}
```

Contract developers may have the motivation to declare the `tokenReceived` function `payable` in the `IERC223Recipient` interface contract as it would simplify the workflow for them but this approach will violate a principle of failsafe defaults and open up a possibility of accidental ether deposits that wouldn't be properly handled.

If the `tokenReceived` function is declared `payable` in the `IERC223Recipient`, this would automatically make all the implementations that inherit this interface `payable` too. The `tokenReceived` function MAY only be `payable` in contracts designed to receive ether deposits. The `tokenReceived` function MUST not be `payable` in any contracts which are not designed to receive ether deposits.

In order to avoid a situation where the `tokenReceived` would be declared `payable` in the basic implementation in `IERC223Recipient` interface contract to make the process of implementing [ERC-223](./eip-223.md) compatible contracts more convenient for an average developer, the decision was made to deliver ether via the direct deposit `_to.call{value: msg.value}("");`.

As the result, `tokenReceived` and `receive() payable` must be implemented to explicitly declare that a contract is designed to receive [ERC-223](./eip-223.md) tokens or ether respectively.

### Support of [ERC-223](./eip-223.md) original tokens

Two methods of implementing a Token Converter service were considered: (1) a converter that can only create [ERC-223](./eip-223.md) versions of the existing [ERC-20](./eip-20.md) tokens, and (2) a converter that can create both versions ([ERC-20](./eip-20.md) and [ERC-223](./eip-223.md)) of any original token.

The first approach is to encourage developers to deploy an original token as [ERC-20](./eip-20.md) and then create its [ERC-223](./eip-223.md) version in the converter. If some developers consider [ERC-223](./eip-223.md) as their original standard, then they will be left with the problem of creating their custom [ERC-20](./eip-20.md) version of the token. In addition, if any third party contracts like liquidity pools are using the proposed Token Converter to ensure that a token can be listed on a DEX with two versions and both can be combined within one pool - then such contract would not be able to recognize any original [ERC-223](./eip-223.md) token and it's [ERC-20](./eip-20.md) version as a valid pair of contracts that represent one token available in two standards.

For that reason, the second approach was decided, where the Converter can create [ERC-20](./eip-20.md) wrappers for original [ERC-223](./eip-223.md) tokens.

### Support of `approve` & `transferFrom` functions in the [ERC-223](./eip-223.md) wrapper tokens

This functions are superfluous for an [ERC-223](./eip-223.md) token since the `transfer` function can be used to deposit tokens of this standard to contracts. The current ecosystem is built for [ERC-20](./eip-20.md) tokens, and plenty of multisig contracts rely on accepting tokens deposited without any callback, assuming that a multisig doesn't need to count the number of tokens it stores.

There are other contracts and scenarios where it is necessary to deposit a token to a contract which is relying on an assumption that tokens are deposited without invoking a callback in the recipient. As the result, we can expect that any original deployed [ERC-223](./eip-223.md) tokens will support these functions as token developers strive for backward compatibility with the existing ecosystem. To make tokens deployed by the converter a reference implementation for developers that can be used without any modifications, it was decided to support this functions in the [ERC-223](./eip-223.md) wrapper contracts.

`transferFrom` function does not support error handling and this needs to be considered. It is possible to deposit tokens to a contract which is not designed to receive them by approving X tokens to your address and then calling a `transferFrom(self, contract, X)`. The tokens will be deposited regardless of whether the recipient contract is designed to hold/receive tokens or not. The tokens may get permanently stuck if the recipient contract did not implement the extraction functions. The `approve` & `transferFrom` function is not the default method of token transferring; however, it is not directly used by any wallets or other software that manages tokens. The `transfer` function (which is safe) is used instead. The `transferFrom` function is supposed to be invoked by a contract to pull tokens from the approver.

As a result, the `approve` & `transferFrom` transferring method must be avoided with [ERC-223](./eip-223.md) tokens whenever possible.

### Modified transfer events of the [ERC-223](./eip-223.md) token

The pure [ERC-223](./eip-223.md) token implementation has the following event emitted on a token transfer: `event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data)`. This events are different from ones emitted by [ERC-20](./eip-20.md) tokens and may not be recognized appropriately by existing blockchain explorers, wallets and other services that browse token transfers history.

Events were considered insignificant in the standard as they do not affect the logic of the token, its workflow, or its security. When developing the Converter, compatibility with the existing ecosystem was prioritized

### `standard()` function usage for the introspection

The main existing method of introspection is currently [ERC-165](./eip-165.md), which inspects the signatures of functions implemented in a contract. However, It is impossible to differentiate an [ERC-20](./eip-20.md) token from an [ERC-223](./eip-223.md) token by just browsing their functions without delving into their internal logic.

Here is a token and it is impossible to identify whether it should be treated as [ERC-20](./eip-20.md) or [ERC-223](./eip-223.md) because it depends on the actual implemenation of it's `transfer` function logic.

```solidity
abstract contract Token {
    function name() external virtual returns (string memory);
    function symbol() external virtual returns (string memory);
    function decimals() external virtual returns (uint8);

    function transfer(address, uint256) external virtual returns (bool);
    function approve(address, uint256) external virtual returns (bool);
    function transferFrom(address, address, uint256) external virtual returns (bool);
}
```

In a case of this implementation the token will behave as [ERC-20](./eip-20.md):

```solidity
    function transfer(address _to, uint256 _amount) external virtual returns (bool)
    {
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
}
```

In a case of this implementation the token will behave as [ERC-223](./eip-223.md):

```solidity
    function transfer(address _to, uint256 _amount) external virtual returns (bool)
    {
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        if(_to.isContract())
        {
            IERC223Recipient(_to).tokenReceived(msg.sender, _amount, hex"000000");
        }
    }
}
```

Also, plenty of tokens do not implement [ERC-165](./eip-165.md) introspection at all. As a result, it was decided to implement a particular `standard() returns (uint32)` function in all [ERC-223](./eip-223.md) wrappers created by the Converter and assume that original [ERC-223](./eip-223.md) tokens may explicitly declare themselves as [ERC-223](./eip-223.md) by implementing the same function too. It is assumed that if a token does not implement this function, then it is [ERC-20](./eip-20.md).

This method of token standard introspection is more precise than [ERC-165](./eip-165.md).

## Backward Compatibility

This proposal is supposed to eliminate the backward compatibility concerns for different token standards, making them interchangeable and interoperable.

This service is the first of its kind and has backward compatibility issues, as it has no predecessors.

## Reference Implementation

```solidity

pragma solidity =0.8.19;

// ERC-7417 Token Converter and all the related contracts.
// https://eips.ethereum.org/EIPS/eip-7417

// Written by Dexaran (dexaran@ethereumclassic.org & x.com/Dexaran)
// ERC-20 token standard contains a known flaw described here: https://medium.com/dex223/known-problems-of-erc20-token-standard-e98887b9532c
// If a ERC-20 token is transferred to a smart-contract which is not designed to receive them
// then instead of an error the transfer successfully moves tokens to the balance of the contract.
// In this case ERC-20 tokens get permanently stuck on the balance of the contract they were deposited to.
// As of 31 November, 2024 $83,000,000 worth of ERC-20 tokens were lost because of this issue https://dexaran.github.io/erc20-losses/
// In order to mitigate this problem the Converter and wrapper contracts implement an extraction function which allows the
// address that deployed them to extract any stuck ERC-20 tokens.
// Contact information is provided so that anyone who has deposited tokens into the contract can request a token withdrawal.

library Address {
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Metadata is IERC20 {
    /// @return The name of the token
    function name() external view returns (string memory);

    /// @return The symbol of the token
    function symbol() external view returns (string memory);

    /// @return The number of decimal places the token has
    function decimals() external view returns (uint8);
}

abstract contract IERC223Recipient {
    function tokenReceived(address _from, uint _value, bytes memory _data) public virtual returns (bytes4)
    {
        return 0x8943ec02;
    }
}

abstract contract ERC165 {
    /*
     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7
     */
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
    mapping(bytes4 => bool) private _supportedInterfaces;

    constructor () {
        // Derived contracts need only register support for their own interfaces,
        // we register support for ERC165 itself here
        _registerInterface(_INTERFACE_ID_ERC165);
    }
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return _supportedInterfaces[interfaceId];
    }
    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");
        _supportedInterfaces[interfaceId] = true;
    }
}

abstract contract IERC223 {
    function name()        public view virtual returns (string memory);
    function symbol()      public view virtual returns (string memory);
    function decimals()    public view virtual returns (uint8);
    function totalSupply() public view virtual returns (uint256);
    function balanceOf(address who) public virtual view returns (uint);
    function transfer(address to, uint value) public virtual returns (bool success);
    function transfer(address to, uint value, bytes calldata data) public payable virtual returns (bool success);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}

interface standardERC20
{
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

/**
 * @dev Interface of the ERC20 standard.
 */
interface IERC223WrapperToken {
    function name()     external view returns (string memory);
    function symbol()   external view returns (string memory);
    function decimals() external view returns (uint8);
    function standard() external view returns (string memory);
    function origin()   external  view returns (address);

    function totalSupply()                                            external view returns (uint256);
    function balanceOf(address account)                               external view returns (uint256);
    function transfer(address to, uint256 value)                      external payable returns (bool);
    function transfer(address to, uint256 value, bytes calldata data) external payable returns (bool);
    function allowance(address owner, address spender)                external view returns (uint256);
    function approve(address spender, uint256 value)                  external returns (bool);
    function transferFrom(address from, address to, uint256 value)    external returns (bool);

    function mint(address _recipient, uint256 _quantity) external;
    function burn(address _recipient, uint256 _quantity) external;
}

interface IERC20WrapperToken {
    function name()     external view returns (string memory);
    function symbol()   external view returns (string memory);
    function decimals() external view returns (uint8);
    function standard() external view returns (string memory);
    function origin()   external  view returns (address);

    function totalSupply()                                         external view returns (uint256);
    function balanceOf(address account)                            external view returns (uint256);
    function transfer(address to, uint256 value)                   external returns (bool);
    function allowance(address owner, address spender)             external view returns (uint256);
    function approve(address spender, uint256 value)               external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function mint(address _recipient, uint256 _quantity) external;
    function burn(address _recipient, uint256 _quantity) external;
}

contract ERC20Rescue
{
    // ERC20 tokens can get stuck on a contracts balance due to lack of error handling.
    //
    // The author of the ERC7417 can extract ERC20 tokens if they are mistakenly sent
    // to the wrapper-contracts balance.
    // Contact dexaran@ethereumclassic.org
    address public extractor = 0x01000B5fE61411C466b70631d7fF070187179Bbf;
    
    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function rescueERC20(address _token, uint256 _amount) external 
    {
        safeTransfer(_token, extractor, _amount);
    }
}

contract ERC223WrapperToken is IERC223, ERC165, ERC20Rescue
{
    address public creator = msg.sender;
    address private wrapper_for;

    mapping(address account => mapping(address spender => uint256)) private allowances;

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event TransferData(bytes data);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    function set(address _wrapper_for) external
    {
        require(msg.sender == creator);
        wrapper_for = _wrapper_for;
    }

    uint256 private _totalSupply;

    mapping(address => uint256) private balances; // List of user balances.

    function totalSupply() public view override returns (uint256)             { return _totalSupply; }
    function balanceOf(address _owner) public view override returns (uint256) { return balances[_owner]; }


    /**
     * @dev The ERC165 introspection function.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return
            interfaceId == type(IERC20).interfaceId ||
            interfaceId == type(standardERC20).interfaceId ||
            interfaceId == type(IERC223WrapperToken).interfaceId ||
            interfaceId == type(IERC223).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev Standard ERC223 transfer function.
     *      Calls _to if it is a contract. Does not transfer tokens to contracts
     *      which do not explicitly declare the tokenReceived function.
     * @param _to    - transfer recipient. Can be contract or EOA.
     * @param _value - the quantity of tokens to transfer.
     * @param _data  - metadata to send alongside the transaction. Can be used to encode subsequent calls in the recipient.
     */
    function transfer(address _to, uint _value, bytes calldata _data) public payable override returns (bool success)
    {
        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
        if (msg.value > 0) 
        {
            (bool sent, bytes memory data) = _to.call{value: msg.value}("");
            require(sent);
        }
        if(Address.isContract(_to)) {
            IERC223Recipient(_to).tokenReceived(msg.sender, _value, _data);
        }
        emit Transfer(msg.sender, _to, _value); // Old ERC20 compatible event.
        emit TransferData(_data);               // Log _data in a separate event to keep `event Transfer(...)` compatible
                                                // with the ERC-20 ecosystem.

        return true;
    }

    /**
     * @dev Standard ERC223 transfer function without _data parameter. It is supported for 
     *      backwards compatibility with ERC20 services.
     *      Calls _to if it is a contract. Does not transfer tokens to contracts
     *      which do not explicitly declare the tokenReceived function.
     * @param _to    - transfer recipient. Can be contract or EOA.
     * @param _value - the quantity of tokens to transfer.
     */
    function transfer(address _to, uint _value) public override returns (bool success)
    {
        bytes memory _empty = hex"00000000";
        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
        if(Address.isContract(_to)) {
            IERC223Recipient(_to).tokenReceived(msg.sender, _value, _empty);
        }
        emit Transfer(msg.sender, _to, _value); // Old ERC20 compatible event. Added for backwards compatibility reasons.

        return true;
    }

    function name() public view override returns (string memory)   { return IERC20Metadata(wrapper_for).name(); }
    function symbol() public view override returns (string memory) { return string.concat(IERC20Metadata(wrapper_for).symbol(), "223"); }
    function decimals() public view override returns (uint8)       { return IERC20Metadata(wrapper_for).decimals(); }
    function standard() public pure returns (uint32)               { return 223; }
    function origin() public view returns (address)                { return wrapper_for; }


    /**
     * @dev Minting function which will only be called by the converter contract.
     * @param _recipient - the address which will receive tokens.
     * @param _quantity  - the number of tokens to create.
     */
    function mint(address _recipient, uint256 _quantity) external
    {
        require(msg.sender == creator, "Wrapper Token: Only the creator contract can mint wrapper tokens.");
        balances[_recipient] += _quantity;
        _totalSupply += _quantity;
    }

    /**
     * @dev Burning function which will only be called by the converter contract.
     * @param _quantity  - the number of tokens to destroy. TokenConverter can only destroy tokens on it's own address.
     *                     Only the token converter is allowed to burn wrapper-tokens.
     */
    function burn(uint256 _quantity) external
    {
        require(msg.sender == creator, "Wrapper Token: Only the creator contract can destroy wrapper tokens.");
        balances[msg.sender] -= _quantity;
        _totalSupply -= _quantity;
    }

    // ERC20 functions for backwards compatibility.

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address _spender, uint _value) public returns (bool) {
        require(_spender != address(0), "ERC223: Spender error.");

        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool) {

        require(allowances[_from][msg.sender] >= _value, "ERC223: Insufficient allowance.");

        balances[_from] -= _value;
        allowances[_from][msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);

        return true;
    }
}

contract ERC20WrapperToken is IERC20, ERC165, ERC20Rescue
{
    address public creator = msg.sender;
    address public wrapper_for;

    mapping(address account => mapping(address spender => uint256)) private allowances;

    function set(address _wrapper_for) external
    {
        require(msg.sender == creator);
        wrapper_for = _wrapper_for;
    }

    uint256 private _totalSupply;
    mapping(address => uint256) private balances; // List of user balances.


    function balanceOf(address _owner) public view override returns (uint256) { return balances[_owner]; }

    function name()        public view  returns (string memory) { return IERC20Metadata(wrapper_for).name(); }
    function symbol()      public view  returns (string memory) { return string.concat(IERC223(wrapper_for).symbol(), "20"); }
    function decimals()    public view  returns (uint8)         { return IERC20Metadata(wrapper_for).decimals(); }
    function totalSupply() public view override returns (uint256)       { return _totalSupply; }
    function origin()      public view returns (address)                { return wrapper_for; }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return
            interfaceId == type(IERC20).interfaceId ||
            interfaceId == type(IERC20WrapperToken).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function transfer(address _to, uint _value) public override returns (bool success)
    {
        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function mint(address _recipient, uint256 _quantity) external
    {
        require(msg.sender == creator, "Wrapper Token: Only the creator contract can mint wrapper tokens.");
        balances[_recipient] += _quantity;
        _totalSupply += _quantity;
    }

    function burn(address _from, uint256 _quantity) external
    {
        require(msg.sender == creator, "Wrapper Token: Only the creator contract can destroy wrapper tokens.");
        balances[_from] -= _quantity;
        _totalSupply    -= _quantity;
    }

    function allowance(address owner, address spender) public view virtual returns (uint256) {
        return allowances[owner][spender];
    }

    function approve(address _spender, uint _value) public returns (bool) {

        // Safety checks.

        require(_spender != address(0), "ERC20: Spender error.");

        allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool) {

        require(allowances[_from][msg.sender] >= _value, "ERC20: Insufficient allowance.");

        balances[_from] -= _value;
        allowances[_from][msg.sender] -= _value;
        balances[_to] += _value;

        emit Transfer(_from, _to, _value);

        return true;
    }
}

contract ERC7417TokenConverter is IERC223Recipient
{
    event ERC223WrapperCreated(address indexed _token, address indexed _ERC223Wrapper);
    event ERC20WrapperCreated(address indexed _token, address indexed _ERC20Wrapper);

    mapping (address => ERC223WrapperToken) public erc223Wrappers; // A list of token wrappers. First one is ERC20 origin, second one is ERC223 version.
    mapping (address => ERC20WrapperToken)  public erc20Wrappers;

    mapping (address => address)            public erc223Origins;
    mapping (address => address)            public erc20Origins;
    mapping (address => uint256)            public erc20Supply; // Token => how much was deposited.

    function getERC20WrapperFor(address _token) public view returns (address)
    {
        return address(erc20Wrappers[_token]);
    }

    function getERC223WrapperFor(address _token) public view returns (address)
    {
        return address(erc223Wrappers[_token]);
    }

    function getERC20OriginFor(address _token) public view returns (address)
    {
        return (address(erc20Origins[_token]));
    }

    function getERC223OriginFor(address _token) public view returns (address)
    {
        return (address(erc223Origins[_token]));
    }

    function predictWrapperAddress(address _token,
                                   bool    _isERC20 // Is the provided _token a ERC20 or not?
                                                    // If it is set as ERC20 then we will predict the address of a 
                                                    // ERC223 wrapper for that token.
                                                    // Otherwise we will predict ERC20 wrapper address.
                                  ) view external returns (address)
    {
        bytes memory _bytecode;
        if(_isERC20)
        {
            _bytecode = type(ERC223WrapperToken).creationCode;
        }
        else
        {
            _bytecode = type(ERC20WrapperToken).creationCode;
        }

        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff), address(this), keccak256(abi.encode(_token)), keccak256(_bytecode)
          )
        );

        return address(uint160(uint(hash)));
    }

    function tokenReceived(address _from, uint _value, bytes memory /* _data */) public override returns (bytes4)
    {
        require(erc223Origins[msg.sender] == address(0), "Error: creating wrapper for a wrapper token.");
        // There are two possible cases:
        // 1. A user deposited ERC223 origin token to convert it to ERC20 wrapper
        // 2. A user deposited ERC223 wrapper token to unwrap it to ERC20 origin.

        if(erc20Origins[msg.sender] != address(0))
        {
            // Origin for deposited token exists.
            // Unwrap ERC-223 wrapper.

            erc20Supply[erc20Origins[msg.sender]] -= _value;
            safeTransfer(erc20Origins[msg.sender], _from, _value);

            ERC223WrapperToken(msg.sender).burn(_value);

            return this.tokenReceived.selector;
        }
        // Otherwise origin for the sender token doesn't exist
        // There are two possible cases:
        // 1. ERC20 wrapper for the deposited token exists
        // 2. ERC20 wrapper for the deposited token doesn't exist and must be created.
        else if(address(erc20Wrappers[msg.sender]) == address(0))
        {
            // Create ERC-20 wrapper if it doesn't exist.
            createERC20Wrapper(msg.sender);
        }

        // Mint ERC-20 wrapper tokens for the deposited ERC-223 token
        // if the ERC-20 wrapper didn't exist then it was just created in the above statement.
        erc20Wrappers[msg.sender].mint(_from, _value);
        return this.tokenReceived.selector;
    }

    function createERC223Wrapper(address _token) public returns (address)
    {
        require(address(erc223Wrappers[_token]) == address(0), "ERROR: Wrapper exists");
        require(!isWrapper(_token), "Error: Creating wrapper for a wrapper token");
        
        ERC223WrapperToken _newERC223Wrapper     = new ERC223WrapperToken{salt: keccak256(abi.encode(_token))}();
        _newERC223Wrapper.set(_token);
        erc223Wrappers[_token]                   = _newERC223Wrapper;
        erc20Origins[address(_newERC223Wrapper)] = _token;

        emit ERC223WrapperCreated(_token, address(_newERC223Wrapper));
        return address(_newERC223Wrapper);
    }

    function createERC20Wrapper(address _token) public returns (address)
    {
        require(address(erc20Wrappers[_token]) == address(0), "ERROR: Wrapper already exists.");
        require(!isWrapper(_token), "Error: Creating wrapper for a wrapper token");

        ERC20WrapperToken _newERC20Wrapper       = new ERC20WrapperToken{salt: keccak256(abi.encode(_token))}();
        _newERC20Wrapper.set(_token);
        erc20Wrappers[_token]                    = _newERC20Wrapper;
        erc223Origins[address(_newERC20Wrapper)] = _token;

        emit ERC20WrapperCreated(_token, address(_newERC20Wrapper));
        return address(_newERC20Wrapper);
    }

    function wrapERC20toERC223(address _ERC20token, uint256 _amount) public returns (bool)
    {
        // If there is no active wrapper for a token that user wants to wrap
        // then create it.
        if(address(erc223Wrappers[_ERC20token]) == address(0))
        {
            createERC223Wrapper(_ERC20token);
        }
        uint256 _converterBalance = IERC20(_ERC20token).balanceOf(address(this)); // Safety variable.
        safeTransferFrom(_ERC20token, msg.sender, address(this), _amount);

        _amount = IERC20(_ERC20token).balanceOf(address(this)) - _converterBalance;
        erc20Supply[_ERC20token] += _amount;

        erc223Wrappers[_ERC20token].mint(msg.sender, _amount);

        return true;
    }

    function unwrapERC20toERC223(address _ERC20token, uint256 _amount) public returns (bool)
    {
        require(IERC20(_ERC20token).balanceOf(msg.sender) >= _amount, "Error: Insufficient balance.");
        require(erc223Origins[_ERC20token] != address(0), "Error: provided token is not a ERC-20 wrapper.");

        ERC20WrapperToken(_ERC20token).burn(msg.sender, _amount);

        safeTransfer(erc223Origins[_ERC20token], msg.sender, _amount);

        return true;
    }

    function convertERC20(address _token, uint256 _amount) public returns (bool)
    {
        if(isWrapper(_token)) return unwrapERC20toERC223(_token, _amount);
        else return wrapERC20toERC223(_token, _amount);
    }

    function isWrapper(address _token) public view returns (bool)
    {
        return erc20Origins[_token] != address(0) || erc223Origins[_token] != address(0);
    }

    function extractStuckERC20(address _token) external 
    {
        require(msg.sender == address(0x01000B5fE61411C466b70631d7fF070187179Bbf));

        safeTransfer(_token, address(0x01000B5fE61411C466b70631d7fF070187179Bbf), IERC20(_token).balanceOf(address(this)) - erc20Supply[_token]);
    }
    
    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }
}
```

## Security Considerations

1. While it is possible to implement a service that converts any token standard to any other standard, it is better to keep different standard convertors separate. Different standards may contain specific logic and require different conversion approaches. This proposal focuses on [ERC-20](./eip-20.md) and [ERC-223](./eip-223.md) upgradeability.
2. [ERC-20](./eip-20.md) tokens can be deposited to any contract directly with `transfer` function. This may result in a permanent loss of tokens because it is impossible to recognize this transaction on the recipients' side. Therefore, wrapper-ERC-20 tokens are prone to this problem as they are compatible with the [ERC-20](./eip-20.md) standard. `rescueERC20` function is implemented to address this problem.
3. Token Converter relies on [ERC-20](./eip-20.md) `approve` & `transferFrom` method of depositing assets. Any related issues must be taken into account. `approve` and `transferFrom` are two separate transactions so it is required to make sure `approval` was successful before relying on `transferFrom`.
4. This is a common practice for UI services to prompt a user to issue unlimited `approval` on any contract that may withdraw tokens from the user. This puts users funds at risk and is not recommended.
5. No reliable token standard introspection method guarantees that a token implements a particular token standard. It is possible to artificially construct a token that will pretend it is an [ERC-20](./eip-20.md) token that implements `approve & transferFrom` but simultaneously implements [ERC-223](./eip-223.md) logic of transferring via `transfer` function. Creating an [ERC-223](./eip-223.md) wrapper for this [ERC-20](./eip-20.md)-[ERC-223](./eip-223.md) hybrid implementation in the Token Converter can be possible. This does not pose any threat for the workflow of the Token Converter itself. However, it must be considered that if a token has [ERC-223](./eip-223.md) wrapper in the Token Converter, it does not automatically mean the origin is fully compatible with the [ERC-20](./eip-20.md) standard. introspection methods must be used to determine the origin's compatibility with any existing standard.
6. Token Converter does not verify the standard of a provided token when it is asked to create a wrapper for it due to the lack of a reliable standard introspection method. It is possible to call `createERC20Wrapper` function and provide an address of an existing [ERC-20](./eip-20.md) token. The Token Converter will successfully create a [ERC-20](./eip-20.md) wrapper for that [ERC-20](./eip-20.md) original token. Creating an [ERC-223](./eip-223.md) wrapper for that exact original [ERC-20](./eip-20.md) token is also possible. This does not threaten the Converter's workflow, but it must be considered that any token, regardless of its original standard, may have up to two wrappers created by the Converter, one for each standard. Any wrapper token must have precisely one origin. It is not possible to create a wrapper for a wrapper.
7. The Token Converter only holds the original tokens deposited during the conversion process. It assumes that tokens do not decay over time and that the converter's token balance does not decrease. Suppose a token implements burning logic or a decaying supply that may impact the converter's balance. In that case, the Converter must not be used to deploy an alternative version of that token, as it will not be able to guarantee enough tokens for the conversion at any time.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
